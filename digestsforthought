#!/usr/bin/env python

import os
import twitter
from sparkpost import SparkPost
import random
import json

def FetchConfig():
    configfile = open("config.json")
    return json.load(configfile)

config = FetchConfig()

# XXX: Support getting these from enviroment variables again.
# And/or a configuration file that doesn't contain rest of settings.
#
#twitter_consumer_key=os.environ.get('TWITTER_CONSUMER_KEY')
#twitter_consumer_secret=os.environ.get('TWITTER_CONSUMER_SECRET')
#twitter_access_token_key=os.environ.get('TWITTER_ACCESS_TOKEN_KEY')
#twitter_access_token_secret=os.environ.get('TWITTER_ACCESS_TOKEN_SECRET')
#
#sparkpost_api_key=os.environ.get('SPARKPOST_API_KEY')

twitter_consumer_key=config["twitter_consumer_key"]
twitter_consumer_secret=config["twitter_consumer_secret"]
twitter_access_token_key=config["twitter_access_token_key"]
twitter_access_token_secret=config["twitter_access_token_secret"]

sparkpost_api_key=config["sparkpost_api_key"]

# XXX: how do I ship an app with this consumer key+secret so no-one can decode them?
api = twitter.Api(consumer_key=twitter_consumer_key,
                  consumer_secret=twitter_consumer_secret,
                  access_token_key=twitter_access_token_key,
                  access_token_secret=twitter_access_token_secret)

sp = SparkPost(sparkpost_api_key)

#print(api.VerifyCredentials())

# XXX: Allow retweets to be skipped?
def FetchTweets(config):
    results=[]

    for screen_name in config['screen_names']:
        chosen=[]
        name=''
        statuses = api.GetUserTimeline(screen_name=screen_name, count=config['fetch_per_user'])
        for i in range(0, config['select_per_user']):
            # XXX: Don't allow duplicates
            s = random.choice(statuses)
            #print(s)
            name = s.user.name
            chosen.append(s)

        results.append({ 'screen_name': screen_name, 'name': name, 'chosen': chosen })

    return results

# XXX: Nicer formatting (w/ images?) for tweets
def FormatTweets(config, results):
    # XXX: Datestamp in subject
    subject='Digests for Thought: Random tweets'

    text='\n'
    html='''
<html>
<head><title>%s</title></head>
<body>
''' % (subject)

    for r in results:
        text += "%s (%s)\n\n" % (r['screen_name'], r['name'])
        html += "<p><b>@%s (%s)</b></p>\n" % (r['screen_name'], r['name'])
        html += "<p><ul>\n"

        for s in r['chosen']:
            # XXX: Eat whitespace in text
            link = "https://twitter.com/%s/status/%s" % (s.user.screen_name, s.id_str)
            # Click tracking is really distracting for links in the text part,
            # so disable click tracking. Also, use a pipe separator
            # to work around an apparent bug where link-attr seems to be ignored
            # in the link parser: "[ link[[link-attr]] ]" doesn't seem to work.
            text += " * %s | %s[[data-msys-clicktrack=\"0\"]]\n" % (s.text, link)
            html += '<li>%s [ <a href="%s">View tweet</a> ]</li>\n' % (s.text, link)

        text += '\n'
        html += '</ul></p>\n'

    html += '''
</body>
</html>
'''

    return { 'subject': subject, 'text': text, 'html': html }

def handler(event, context):
    config = FetchConfig()
    results = FetchTweets(config)
    formatted = FormatTweets(config, results)

    response = sp.transmissions.send(
        recipients=config['recipients'],
        from_email=config['sender'],
        subject=formatted['subject'],
        text=formatted['text'],
        html=formatted['html']
    )

    # Convert this into success/failure
    print(response)

if __name__ == "__main__":
    handler(None, None)

